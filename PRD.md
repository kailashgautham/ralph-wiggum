# Ralph Self-Improvement Plan

Ralph is a self-improving loop. Each iteration, Claude reads this file and progress.txt, picks the next uncompleted task, implements it, commits the change, and marks it done.

**Important:** If all tasks are completed, review the codebase for weaknesses and append new improvement tasks to the Tasks section below before proceeding. There should always be work to do.

## Tasks
- [ ] Deduplicate retry/backoff logic in ralph_run_main_call and ralph_run_planning_call: both functions in ralph-lib.sh implement an almost identical while-loop with exponential backoff (differing only in whether output is tee'd to a tmpfile for capture or streamed directly to a log); extract a shared internal helper _ralph_invoke_claude_with_retry that accepts the claude command array and a "capture to file" flag, runs the retry loop including the credit-exhaustion branch, and returns exit_code; rewrite ralph_run_main_call and ralph_run_planning_call as thin wrappers that build their respective cmd arrays and delegate to the helper, eliminating the duplicated while/sleep/backoff code
- [ ] Add tests for docker-ralph.sh status and --dry-run delegating to ralph.sh on the host: these two subcommands exec ralph.sh directly without Docker, but run_tests.sh has no coverage of this path; add two tests that set up a minimal git repo with PRD.md, provide a stub docker binary on PATH that always exits non-zero (to prove Docker is never invoked), and run docker-ralph.sh status / docker-ralph.sh --dry-run from inside the repo; assert exit 0 and that the output contains "Ralph Status" or "Next task:" respectively
- [ ] Add a RALPH_ITER_HOOK environment variable that is eval'd at the start of each iteration in ralph.sh before the Claude invocation: when RALPH_ITER_HOOK is set, export RALPH_CURRENT_ITER (the current iteration number, 1-based) and RALPH_MAX_ITER (the value of MAX) then run eval "$RALPH_ITER_HOOK" at the top of the for-loop body immediately before ralph_run_main_call, and log a one-line notice to RUN_LOG when the hook is configured; document RALPH_ITER_HOOK, RALPH_CURRENT_ITER, and RALPH_MAX_ITER in ralph.sh --help, docker-ralph.sh --help (and its ENV_ARGS forwarding block), and README.md's environment variables table; add one test to tests/run_tests.sh that sets RALPH_ITER_HOOK to write RALPH_CURRENT_ITER to a file and asserts the file contains "1" after a single iteration
- [ ] Fire _ralph_fire_hook on SIGINT and SIGTERM exits: the handle_signal function in ralph.sh (lines 132–140) exits cleanly but never calls _ralph_fire_hook, so RALPH_COMPLETE_HOOK is silently skipped when the loop is interrupted by a signal; export RALPH_EXIT_REASON="signal" and call _ralph_fire_hook "signal" inside handle_signal immediately before exit 0; document "signal" as a fourth possible RALPH_EXIT_REASON value in ralph.sh --help, docker-ralph.sh --help, and README.md; add a test to tests/run_tests.sh that sends SIGTERM to a running ralph.sh and asserts that RALPH_COMPLETE_HOOK fires with RALPH_EXIT_REASON=signal
- [ ] Move DEFAULT_PROMPT out of ralph.sh and ralph-once.sh and into ralph-lib.sh as RALPH_DEFAULT_PROMPT: both scripts currently define the identical DEFAULT_PROMPT string independently (ralph.sh lines 159–162, ralph-once.sh lines 104–107), so they can silently diverge if one is edited; define RALPH_DEFAULT_PROMPT once in ralph-lib.sh alongside RALPH_DEFAULT_PLAN_PROMPT, then in both ralph.sh and ralph-once.sh replace the local DEFAULT_PROMPT definition and usage with ${RALPH_DEFAULT_PROMPT}; no behaviour change is expected — verify by running the existing test suite
- [ ] Guard ralph_handle_complete against silent progress loss when the planning call fails: ralph_run_planning_call logs a warning and returns 1 when all retry attempts are exhausted, but ralph_handle_complete still archives and resets progress.txt unconditionally (ralph-lib.sh lines 285–288), leaving the project with an empty task list and no new PRD tasks; fix this by checking the return value of ralph_run_planning_call and, if it fails, skipping the archive/reset step and instead logging a clear error message to RUN_LOG (and stdout) explaining that progress.txt was preserved and the operator should resolve the planning failure manually before restarting; also add a test that mocks a permanently-failing claude binary and asserts that progress.txt still contains the original [DONE] lines after ralph_handle_complete is invoked
- [ ] Restrict log rotation in ralph.sh to files with a .log extension: the mapfile in ralph.sh line 118 uses 'ls -t "$LOGS_DIR"' which lists all files in logs/ including .tmp scratch files and any other artifacts, so non-log files count against RALPH_LOG_KEEP and may be unexpectedly deleted; replace the ls invocation with one that filters by extension, e.g. 'ls -t "$LOGS_DIR"/*.log 2>/dev/null', and update the accompanying test (test 12 in tests/run_tests.sh) to verify that a non-.log file placed in logs/ is not counted against the limit and is not deleted by rotation
